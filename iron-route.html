<link rel="import" href="../polymer/polymer.html">
<!--
`iron-route` ties window URL to your application's state. Example usage:
- select which `iron-page` to display
- store form data in the URL for sharing, bookmarks

`iron-route` supports modern router features:
- Express-style path matching
- aliases
- nested routes
- transition callbacks with abort: willDeactivate, willActivate
- navigation API: transitionTo, replaceWith

It is implemented on top of `Polymer.IronRouterManager` routing library.
The library can be configured with `iron-router-config` element.

### Simple example
```
  <template is="dom-bind">
    <iron-route route="/:topmenu" topmenu="{{selected}}"></iron-route>
    <iron-pages selected="{{selected}}">
      <div>Page 1</div>
      <div>Page 2</div>
      <div>Page 3</div>
    </iron-pages>
  </template>
```
This example will bind currently selected page to the URL. Changing the URL
will change the page, changing the page will change the URL.

### Defining the route

#### Express-style routes
Route is defined with `route` attribute. It is usually specified as an express-style string. Examples:

`/main/about` -- plain route

`/users/:id` -- route with routeParameters

`/users/(.*)` -- wildcard route

Route paramaters are reflected to element properties. Use Polymer bindings
to work with them. Example:

```
  <iron-route route="/topmenu/:selected" selected="{{mySelection}}></iron-route>
```
This route would match `/topmenu/about`, `/topmenu/main`, etc. When route is active,
`selected` property will reflect the `:selected` match. You can bind to `selected` to change your
ui state depending on its value.

#### Aliases
Route can also be specifed as an alias, refering to previously defined route. Alias
routes are prefixed by '@' (configurable with iron-router-config)
Example:
```
  <iron-route route="/topmenu/about" alias="about"></iron-route>
  <iron-route route="@alias"></iron-route>
```
Second route is an alias for the first. Alias routes activate whenever original route is active, and can have their own transition callbacks.

### Navigation

Navigation is triggered by:
- window's URL change
- calling navigation routines: `transitionTo`, `replaceWith`
- changing active route's properties

When route changes, `IronRouteManager` searches registered routes for a new match. First matching route becomes new destination. Transition to new destination is initiated.

If route, or its child route, is active, changing it's route properties will trigger a
transition. In the first simple example above, changing `{{selected}}` triggers `iron-route`
to start transition to new destination.

### Transitions

Navigation initiates the transition from source to destination. Transition has 4 phases:

- source.willDeactivate
- destination.willActivate
- source.deactivate
- destination.activate

`iron-route` fires `iron-route-will-activate` and `iron-route-will-deactivate` events during transition. Transition can be cancelled by calling `ev.preventDefault()`.

Cancelling transitions is mostly used for forms with unsaved changes.

`IronRouteManager` offers asynchronous route transitions, but this functionality is not
exposed in `iron-route`

### Nested routes

Routes can be nested. Nested routes's url is a concatenation of its parents route, and given route. Nesting is useful when composing components.

Nested routes attribute reflection, and activation are slightly more complex than ordinary routes.

The main principles are:
- routes reflect only attributes directly defined, and not the parent's attributes.
- attribute navigation is enabled in parents of active routes. Changing parent's attribute
will navigate to route defined by parent, and not one defined by child.

Lets look at an example:

```
  <iron-route id="top" route="/users/:userId" user-id="id">
    <iron-route id="account" route="/account"></iron-route>
    <iron-route id="review" route="/review/:reviewId"></iron-route>
  </iron-route>
```

In the HTML below, normally invisible attributes will be shown for illustration purposes.

----
Current URL `/users/1`:
- "#top" is active.
- `#top.userId` is '1'
- changing `#top.userId` will trigger navigation because it is active

```
  <iron-route id="top" route="/users/:userId" user-id="1" active>
```
----
Current URL `/users/1/account`
- "#account" is active, because it is a nested route, and its full url is `/users/:userId/account`
- "#account.userId" is undefined. Nested routes only reflect properties defined by given route, not its parents.
- `#top.userId` is '1'. When child route is activated, the properties inherited from parent will be reflected in the parent.
- "#top" has an active child
- changing `#top.userId` will trigger navigation because it has an active child

```
  <iron-route id="top" route="/users/:userId" user-id="1" child-active>
    <iron-route id="account" route="/account" active>
```
----
Current URL `/users/1/review/5`
- "#review" is active, because nested, with full URL: `/users/:userId/review/:reviewId`
- "#review.reviewId" is '5'
- "#review.userId" is undefined
- "#top.userId" is '1'
- "#top.reviewId" is undefined
- "#top" has an active child
- changing '#review.reviewID" will trigger navigation
- changing '#top.userId' will trigger navigation
- changing "#top.reviewId" or "#review.userId" will not trigger navigation.
- if "#review.reviewId" is set to "99", new URL will be `/users/1/review99`
- if "#top.userId" is set to "2", new URL will be `/users/2` (child route is not used).

```
  <iron-route id="top" route="/users/:userId" user-id="1" child-active>
    <iron-route id="review" route="/review/reviewId" review-id="5" active>
```

@demo
-->
<dom-module id="iron-route">
  <style>
    :host {
      display: block;
    }
  </style>
  <template>
    <content></content>
  </template>
</dom-module>
<script>

(function() {

  'use strict';

  var ATTR_PREFIX = 'ROUTE_PARAM_';

  Polymer({

    is: 'iron-route',

    properties: {

      /**
       * true if route is active
       */
      active: {
        type: Boolean,
        notify: true,
        readOnly: true,
        reflectToAttribute: true
      },

      /**
       * true if child route is active
       */
      childActive: {
        type: Boolean,
        notify: true,
        readOnly: true
      },

      /**
       * If route is active, routeParams are matching route parameters.
       * Example:
       *
       * If route is `/user/:userId/review/:reviewId`
       * and current URL is `/user/100/review/ABC`
       *
       * routeParam will be `{ userId: "100", reviewId: "ABC" }`
       */
      routeParams: {
        type: Object,
        notify: true,
        readOnly: true
      },

      /**
       * Route specified as:
       * - An express style route (ex: '/foo/:bar')
       * - An alias to an existing route ( '@foo')
       */
      route: {
        type: String,
        observer: '_routeChanged'
      },

      /**
       * Route alias. If this route should have an alias, specify it here.
       */
      routeAlias: {
        type: String
      },

      /**
       * Full path to the route (parent + given)
       */
      fullRoute: {
        type: String,
        computed: '_computeFullRoute(_givenRoute, _parentRoute)',
        observer: '_fullRouteChanged',
        notify: true
      },

      /**
       * User-specified route
       */
      _givenRoute: {
        type: String
      },

      /**
       * Parent route
       */
      _parentRoute: {
        type: String,
        value: ''
      },

      /**
       * nestedChildRoute property is a marker attribute.
       * It is always true, and exists for parents to
       * find children using css attribute selectors.
       */
      nestedChildRoute: {
        type: Boolean,
        value: true,
        reflectToAttribute: true,
        readOnly: true
      }
    },

    /** EVENTS */

    /**
     * Fired before deactivation. preventDefault to cancel transition
     *
     * @event iron-route-will-deactivate
     */

    /**
     * Fired before activation. preventDefault to cancel transition
     *
     * @event iron-route-will-activate
     * @param {object} detail
     * @param {object} detail.activationParams
     */

    /**
     * Fired by child when attached to dom.
     * Parent responds with iron-router-parent-route-changed event
     *
     * @param {Object} detail
     * @param {Element} detail.child element firing the event, used to cross shadowDom boundary
     * @-event iron-router-child-route-added
     */

    /**
     * Fired by parent to immediate children when full parent's full route changes
     *
     * @param {Object} detail
     * @param {Element} detail.parent element firing the event
     * @param {String} route full parent route
     * @-event iron-router-parent-route-changed
     */

    /**
     * Fired by child route when activated.
     *
     * @param {Object} detail
     * @param {object} detail.activationParams -- params that belong to parent
     * @-event iron-router-child-route-activated
     */

    /**
     * Fired by child route when deactivated.
     *
     * @-event iron-router-child-route-deactivated
     */

    listeners: {
      'iron-router-child-route-added': '_handleChildRouteAdded',
      'iron-router-parent-route-changed': '_handleParentRouteChanged',
      'iron-router-child-route-activated': '_handleChildRouteActivated',
      'iron-router-child-route-deactivated': '_handleChildRouteDeactivated'
    },

    created: function() {
      this._boundWillDeactivate = this._willDeactivate.bind(this);
      this._boundDeactivate = this._deactivate.bind(this);
      this._boundWillActivate = this._willActivate.bind(this);
      this._boundActivate = this._activate.bind(this);
    },

    attached: function() {
      this.fire(
        'iron-router-child-route-added',
        { child: this }
      );
    },

    /**
     * Transition to this route.
     *
     * @param {object} routeParams -- must specify all parameters in this route, including any nested routes
     */
    transitionTo: function(routeParams) {
      Polymer.RouteManager.transitionTo(this._routeToken, routeParams);
    },

    /**
     * Replace existing route with this one.
     *
     * @param {object} routeParams -- must specify all parameters in this route, including any nested routes
     */
    replaceWith: function(routeParams) {
      Polymer.RouteManager.replaceWith(this._routeToken, routeParams);
    },

    _handleChildRouteAdded: function(ev) {
      if (ev.srcElement !== this) {
        // console.log('child-route-added', this.id, ev.srcElement.id , ev.srcElement.route);
        ev.stopPropagation();
        this._sendParentChangeToChild(ev.detail.child);
      }
    },

    _handleParentRouteChanged: function(ev) {
      // console.log('parent-route-changed', this.id, ev.detail.route, ev.detail.parent.id);
      this._parentRoute = ev.detail.route;
      this._parentRouteNode = ev.detail.parent;
      ev.stopPropagation();
    },

    _handleChildRouteActivated: function(ev) {
      this._setChildActive(true);
      this._setAndReflectRouteParams(ev.detail.activationParams.routeParams);
      this._fireChildActivated(ev.detail.activationParams);
      ev.stopPropagation();
    },

    _handleChildRouteDeactivated: function() {
      this._setChildActive(false);
    },

    _fireChildActivated: function(activationParams) {
      if (!this._parentRouteNode) {
        return;
      }
      var parentParams = { routeParams: {}};
      if (activationParams.routeParams) {
        // copy only keys not associated with current givenRoute
        for (var p in activationParams.routeParams) {
          if (this._givenKeys.indexOf(p) === -1) {
            parentParams.routeParams[p] = activationParams.routeParams[p];
          }
        }
      }
      this.fire('iron-router-child-route-activated',
        {
          activationParams: parentParams
        },
        {
          node: this._parentRouteNode,
          bubbles: false
        }
      );
    },

    _sendParentChangeToChild: function(child) {
      var ev = new CustomEvent('iron-router-parent-route-changed',
        {
          detail: {
            parent: this,
            route: this.fullRoute
          }
        });
      // console.log('dispatching to', child.id);
      child.dispatchEvent(ev);
    },

    _broadcastPathChangeToChildren: function() {
      var childRoutes = this.querySelectorAll('[nested-child-route]');
      childRoutes = Array.prototype.slice.call(childRoutes);

      function removeChildrenOf(el) {
        var kids = el.querySelectorAll('[nested-child-route]');
        kids = Array.prototype.slice.call(kids);
        childRoutes = childRoutes.filter( function(element) {
          return kids.indexOf(element) === -1;
        });
      };

      for (var i=0; i<childRoutes.length; i++) {
        this._sendParentChangeToChild(childRoutes[i]);
        // do not propagate to children of route we've just notified
        removeChildrenOf(childRoutes[i]);
      }
    },

    _monitorAttributes: function(attributes) {
       // console.log("monitoring", attributes);
      for (var i=0; i<attributes.length; i++) {
        var name = attributes[i];
        Object.defineProperty(this, name, {
          configurable: true,
          enumerable: true,
          get: function() {
            // console.log('get ', name);
            return this[ATTR_PREFIX + name];
          },
          set: function(val) {
            if (val === this[ATTR_PREFIX + name])
              return;
            // console.log('set ', name, val);
            this[ATTR_PREFIX + name] = val;
            this.fire(name + '-changed');
            if (!this._blockParamNavigation && (this.active || this.childActive)) {
              this.debounce('paramNavigation', this._navigateToAttributes);
            }
          }
        });
      }
    },

    _stopMonitoringAttributes: function(attributes) {
      // console.log("stop monitoring", attributes);
      for (var i=0; i<attributes.length; i++) {
        delete this[ATTR_PREFIX + name];
        delete this[name];
      }
    },

    _willDeactivate: function(transaction) {
      var ev = this.fire(
        'iron-route-will-deactivate',
        { transaction: transaction },
        { cancelable: true}
      );
      if (ev.defaultPrevented) {
        transaction.abort();
      }
    },

    _willActivate: function(transaction, activationParams) {
      var ev = this.fire(
        'iron-route-will-activate',
        { transaction: transaction },
        { cancelable: true}
      );
      if (ev.defaultPrevented) {
        transaction.abort();
      }
    },

    _deactivate: function() {
      // console.log("Inactive ", this.route);
      this._setRouteParams(null);
      this._setActive(false);
      if (this._parentRouteNode) {
        this.fire(
          'iron-router-child-route-deactivated',
          { node: this._parentRouteNode }
        );
      }
    },

    _activate: function(transaction, activationParams) {
      // console.log("Active ", this.route);
      this._setAndReflectRouteParams(activationParams.routeParams);
      this._setActive(true);
      this._fireChildActivated(activationParams);
    },

    _setAndReflectRouteParams: function(routeParams) {
      this._setRouteParams(routeParams);
      try {
        this._blockParamNavigation = true;
        for (var i=0, key = this._givenKeys[i]; i<this._givenKeys.length; i++) {
          if (key in routeParams) {
            this[key] = routeParams[key];
          }
          else {
            this[key] = undefined;
          }
        }
      }
      catch(err) {
        console.error("unexpected error", err);
      }
      finally {
        this._blockParamNavigation = false;
      }
    },

    _navigateToAttributes: function() {
      var routeParams = {};
      for (var p in this.routeParams) {
        routeParams[p] = this.routeParams[p];
      }
      for (var i=0, key=this._givenKeys[i]; i<this._givenKeys.length; i++) {
        routeParams[key] = this[key];
      }
      this.transitionTo(routeParams);
    },

    _routeChanged: function(newRoute) {
      if (this._givenKeys) {
        this._stopMonitoringAttributes(
          Polymer.RouteManager.getRouteKeys(this._givenRoute));
      }
      this._givenRoute = newRoute;
      this._givenKeys = Polymer.RouteManager.getRouteKeys(this._givenRoute);
      this._monitorAttributes(this._givenKeys);
    },

    _computeFullRoute: function() {
      return Polymer.RouteManager.concatPaths(this._parentRoute, this._givenRoute);
    },

    _fullRouteChanged: function(newRoute) {
      if (this._routeToken) {
        Polymer.RouteManager.unregister(this._routeToken);
        this._routeToken = null;
      }
      if (newRoute) {
        var options = {
          willDeactivate: this._boundWillDeactivate,
          deactivate: this._boundDeactivate,
          willActivate: this._boundWillActivate,
          activate: this._boundActivate
        }
        if (this.routeAlias) {
          options.alias = routeAlias;
        }
        this._routeToken = Polymer.RouteManager.register(newRoute, options);
      }
      this._broadcastPathChangeToChildren();
    }

  });

})();
</script>
