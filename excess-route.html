<link rel="import" href="../polymer/polymer.html">
<!--
## excess-router

Express-style routing for Polymer

## Example
```html
<my-app>

  <excess-route
    route="/:topmenu"
    topmenu="{{appMenu}}"
  ></excess-route>
  <excess-route route="/*" redirect_to="/first"></excess-route>

  <iron-pages selected="{{appMenu}}" attr_for_selected="name">
    <first-page name="first"></first-page>
    <second-page name="second"></second-page>
  </iron-pages>

</my-app>
```

## Features

`excess-router` is a standard full-featured router, implementing
routing functionality also found in Angular, React, page.js.

- two Polymer elments: `<excess-route>` and `<excess-router-config>`

- Javascript library: `Excess.RouteManager`

- [express-style](https://github.com/component/path-to-regexp) path matching
```
  '/users/:id', '/:topmenu/:submenu?', '/*'
```
- route aliases:
```javascript
  <excess-route route="/:topmenu" name="@main">
  Excess.RouteManager.navigateTo('@main', {topmenu: '0'});
```

- redirection
```html
  <excess-route route="/*" redirect_to="/
```

- route transition lifecycle callbacks: willDeactivate, willActivate

- anchor tag links are routed
```
  <a href="/mainmenu"></>
```

- configurable
  - '#' hash, or '/' path style paths.
  - hashPrefix
  - manual start

- lazy display/loading when you use [lazy-pages](https://github.com/atotic/lazy-pages)

## How to use

`<excess-route>` binds window's URL to its attributes.
Route keys will be bound to `<excess-route>`'s properties. For example:
```html
<my-app>
  <excess-route route="/users/:userId" user-id="{{appUserId}}">
</my-app>
```
`:userId` key match will propagate to `excess-route.userId`, and `my-app.appUserId`.

When window.location is '#/users/1'
- excess-route.userId be 1
- my-app.appUserId will be 1
- setting my-app.appUserId to 999 will cause
  - excess-route.userId to become 999
  - which causes excess-route to call `Excess.RouteManager.navigateTo('/users/999')`
  - which changes window.location to `#/users/999`

Once route's keys have been reflected to your app, use Polymer's bindings to connect your route to `<iron-pages>`,
`<neon-animated-pages>`, `<lazy-pages>`, or whatever your route uses for navigation.

Not all routing use cases are covered just by using `<excess-route>`. If your problems become complex, you can drop down into Javascript and
use `Excess.RouteManager` library and use your JS superpowers.

## Example

How would you use this in Polymer Starter Kit?

```html
<my-app>
  <iron-route route="/:topmenu/:submenu"
    topmenu="{{appRoute}}" submenu="{{submenu}}"></iron-route>
  <paper-menu attr-for-selected="route" selected="{{appRoute}}">
    <a href="#/home" route="home">Home</a>
    <a href="#/users/all" route="users">Users</a>
    <a href="#/contact" route="contact">Contact</a>
  </paper-menu>
  <iron-pages attr-for-selected="route" selected="{{route}}">
    <section route="home">...</section>
    <section route="users">
      <iron-pages attr-for-selected="user" selected="{{submenu}}">
        <section user="all">
          <p>This is the users section</p>
            <a href="#/users/Rob">Rob</a>
        </section>
        <section user="Rob">
          User:<span>{{submenu}}</span>
        </section>
      </iron-pages>
    </section>
  </iron-pages>
</my-app>
```

## Philosophy

## Experimental features

Intially, `<excess-route>`s could be nested. It more than doubled the code size, and I could not come up with a good use case. I've decided
that what I really want is nesting built into the core library.

@demo
-->
<dom-module id="excess-route">
  <style>
    :host {
      display: block;
    }
  </style>
  <template>
    <content></content>
  </template>
</dom-module>
<script>

(function() {

  'use strict';

  var ATTR_PREFIX = 'ROUTE_PARAM_';

  Polymer({

    is: 'excess-route',

    properties: {

      /**
       * true if route is active
       */
      active: {
        type: Boolean,
        notify: true,
        readOnly: true,
        reflectToAttribute: true
      },

      /**
       * true if child route is active
       */
      // childActive: {
      //   type: Boolean,
      //   notify: true,
      //   readOnly: true
      // },

      /**
       * If route is active, routeParams are matching route parameters.
       * Example:
       *
       * If route is `/user/:userId/review/:reviewId`
       * and current URL is `/user/100/review/ABC`
       *
       * routeParam will be `{ userId: "100", reviewId: "ABC" }`
       */
      routeParams: {
        type: Object,
        notify: true,
        readOnly: true
      },

      /**
       * Route specified as:
       * - An express style route (ex: '/foo/:bar')
       * - An alias to an existing route ( '@foo')
       */
      route: {
        type: String,
        observer: '_routeChanged'
      },

      /**
       * Route alias. If this route should have an alias, specify it here.
       */
      routeAlias: {
        type: String,
        value: ""
      },

      /**
       * Route to redirect to. If set, route will redirect inside 'willActivate'
       */
      redirectTo: {
        type: String
      },

      /**
       * Full path to the route (parent + given)
       */
      fullRoute: {
        type: String,
        computed: '_computeFullRoute(_givenRoute, _parentRoute, routeAlias)',
        observer: '_fullRouteChanged',
        notify: true
      },

      /**
       * User-specified route
       */
      _givenRoute: {
        type: String
      },

      /**
       * Parent route
       */
      _parentRoute: {
        type: String,
        value: ''
      },

      /**
       * nestedChildRoute property is a marker attribute.
       * It is always true, and exists for parents to
       * find children using css attribute selectors.
       */
      // nestedChildRoute: {
      //   type: Boolean,
      //   value: true,
      //   reflectToAttribute: true,
      //   readOnly: true
      // }

    },

    /** EVENTS */

    /**
     * Fired before deactivation. preventDefault to cancel transition
     *
     * @event excess-route-will-deactivate
     */

    /**
     * Fired before activation. preventDefault to cancel transition
     *
     * @event excess-route-will-activate
     * @param {object} detail
     * @param {object} detail.activationParams
     */

    /**
     * Fired by child when attached to dom.
     * Parent responds with excess-router-parent-route-changed event
     *
     * @param {Object} detail
     * @param {Element} detail.child element firing the event, used to cross shadowDom boundary
     * @-event excess-router-child-route-added
     */

    /**
     * Fired by parent to immediate children when full parent's full route changes
     *
     * @param {Object} detail
     * @param {Element} detail.parent element firing the event
     * @param {String} route full parent route
     * @-event excess-router-parent-route-changed
     */

    /**
     * Fired by child route when activated.
     *
     * @param {Object} detail
     * @param {object} detail.activationParams -- params that belong to parent
     * @-event excess-router-child-route-activated
     */

    /**
     * Fired by child route when deactivated.
     *
     * @-event excess-router-child-route-deactivated
     */

    // listeners: {
    //   'excess-router-child-route-added': '_handleChildRouteAdded',
    //   'excess-router-parent-route-changed': '_handleParentRouteChanged',
    //   'excess-router-child-route-activated': '_handleChildRouteActivated',
    //   'excess-router-child-route-deactivated': '_handleChildRouteDeactivated'
    // },

    created: function() {
      this._boundWillDeactivate = this._willDeactivate.bind(this);
      this._boundDeactivate = this._deactivate.bind(this);
      this._boundWillActivate = this._willActivate.bind(this);
      this._boundActivate = this._activate.bind(this);
    },

    attached: function() {
      // this.fire(
      //   'excess-router-child-route-added',
      //   { child: this }
      // );
    },

    /**
     * Transition to this route.
     *
     * @param {object} routeParams -- must specify all parameters in this route, including any nested routes
     */
    transitionTo: function(routeParams) {
      Excess.RouteManager.transitionTo(this._routeToken, routeParams);
    },

    /**
     * Replace existing route with this one.
     *
     * @param {object} routeParams -- must specify all parameters in this route, including any nested routes
     */
    replaceWith: function(routeParams) {
      Excess.RouteManager.replaceWith(this._routeToken, routeParams);
    },

    // _handleChildRouteAdded: function(ev) {
      // if (ev.target !== this) {
      //   // console.log('child-route-added', this.id, ev.target.id , ev.target.route);
      //   ev.stopPropagation();
      //   this._sendParentChangeToChild(ev.detail.child);
      // }
    // },

    // _handleParentRouteChanged: function(ev) {
      // // console.log('parent-route-changed', this.id, ev.detail.route, ev.detail.parent.id);
      // this._parentRoute = ev.detail.route;
      // this._parentRouteNode = ev.detail.parent;
      // ev.stopPropagation();
    // },

    // _handleChildRouteActivated: function(ev) {
      // this._setChildActive(true);
      // this._setAndReflectRouteParams(ev.detail.activationParams.routeParams);
      // this._fireChildActivated(ev.detail.activationParams);
      // ev.stopPropagation();
    // },

    // _handleChildRouteDeactivated: function() {
      // this._setChildActive(false);
    // },

    // _fireChildActivated: function(activationParams) {
      // if (!this._parentRouteNode) {
      //   return;
      // }
      // var parentParams = { routeParams: {}};
      // if (activationParams.routeParams) {
      //   // copy only keys not associated with current givenRoute
      //   for (var p in activationParams.routeParams) {
      //     if (this._givenKeys.indexOf(p) === -1) {
      //       parentParams.routeParams[p] = activationParams.routeParams[p];
      //     }
      //   }
      // }
      // this.fire('excess-router-child-route-activated',
      //   {
      //     activationParams: parentParams
      //   },
      //   {
      //     node: this._parentRouteNode,
      //     bubbles: false
      //   }
      // );
    // },

    // _sendParentChangeToChild: function(child) {
      // var ev = new CustomEvent('excess-router-parent-route-changed',
      //   {
      //     detail: {
      //       parent: this,
      //       route: this.fullRoute
      //     }
      //   });
      // // console.log('dispatching to', child.id);
      // child.dispatchEvent(ev);
    // },

    // _broadcastPathChangeToChildren: function() {
      // var childRoutes = this.querySelectorAll('[nested-child-route]');
      // childRoutes = Array.prototype.slice.call(childRoutes);

      // function removeChildrenOf(el) {
      //   var kids = el.querySelectorAll('[nested-child-route]');
      //   kids = Array.prototype.slice.call(kids);
      //   childRoutes = childRoutes.filter( function(element) {
      //     return kids.indexOf(element) === -1;
      //   });
      // };

      // for (var i=0; i<childRoutes.length; i++) {
      //   this._sendParentChangeToChild(childRoutes[i]);
      //   // do not propagate to children of route we've just notified
      //   removeChildrenOf(childRoutes[i]);
      // }
    // },

    _monitorAttributes: function(attributes) {
       // console.log("monitoring", attributes);
      var defProp = function(name) {
        Object.defineProperty(this, name, {
          configurable: true,
          enumerable: true,
          get: function() {
            // console.log('get ', name);
            return this[ATTR_PREFIX + name];
          },
          set: function(val) {
            if (val === this[ATTR_PREFIX + name])
              return;
            // console.log('set ', name, val);
            this[ATTR_PREFIX + name] = val;
            this.fire(name + '-changed');
            if (!this._blockParamNavigation && (this.active || this.childActive)) {
              this.debounce('paramNavigation', this._navigateToAttributes);
            }
          }
        });
      }.bind(this);

      for (var i=0; i<attributes.length; i++) {
        defProp(attributes[i]);
      }
    },

    _stopMonitoringAttributes: function(attributes) {
      // console.log("stop monitoring", attributes);
      for (var i=0; i<attributes.length; i++) {
        delete this[ATTR_PREFIX + name];
        delete this[name];
      }
    },

    _willDeactivate: function(transaction) {
      var ev = this.fire(
        'excess-route-will-deactivate',
        { transaction: transaction },
        { cancelable: true}
      );
      if (ev.defaultPrevented) {
        transaction.abort();
      }
    },

    _willActivate: function(transaction, activationParams) {
      // redirected routes redirect on activation
      if (this.redirectTo) {
        if (this._redirecting) {
          throw new Error("redirect loop detected", this.fullRoute);
        }
        this._redirecting = true;
        transaction.abort( {
          redirectTo: this.redirectTo
        });
        this._redirecting = false;
        return;
      }
      var ev = this.fire(
        'excess-route-will-activate',
        { transaction: transaction },
        { cancelable: true}
      );
      if (ev.defaultPrevented) {
        transaction.abort();
      }
    },

    _deactivate: function() {
      // console.log("Inactive ", this.route);
      this._setRouteParams(null);
      this._setActive(false);
      if (this._parentRouteNode) {
        this.fire(
          'excess-router-child-route-deactivated',
          { node: this._parentRouteNode }
        );
      }
    },

    _activate: function(transaction, activationParams) {
      // console.log("Active ", this.route);
      this._setAndReflectRouteParams(activationParams.routeParams);
      this._setActive(true);
      // this._fireChildActivated(activationParams);
    },

    _setAndReflectRouteParams: function(routeParams) {
      this._setRouteParams(routeParams);
      try {
        this._blockParamNavigation = true;
        for (var i=0; i<this._givenKeys.length; i++) {
          var key = this._givenKeys[i];
          if (key in routeParams) {
            this[key] = routeParams[key];
          }
          else {
            this[key] = undefined;
          }
        }
      }
      catch(err) {
        console.error("unexpected error", err);
      }
      finally {
        this._blockParamNavigation = false;
      }
    },

    _navigateToAttributes: function() {
      var routeParams = {};
      for (var p in this.routeParams) {
        routeParams[p] = this.routeParams[p];
      }
      for (var i=0, key=this._givenKeys[i]; i<this._givenKeys.length; i++) {
        routeParams[key] = this[key];
      }
      this.transitionTo(routeParams);
    },

    _routeChanged: function(newRoute) {
      if (this._givenKeys) {
        this._stopMonitoringAttributes(
          Excess.RouteManager.getRouteKeys(this._givenRoute));
      }
      this._givenRoute = newRoute;
      this._givenKeys = Excess.RouteManager.getRouteKeys(this._givenRoute);
      this._monitorAttributes(this._givenKeys);
    },

    _computeFullRoute: function() {
      return Excess.RouteManager.concatPaths(this._parentRoute, this._givenRoute);
    },

    _fullRouteChanged: function(newRoute) {
      if (this._routeToken) {
        Excess.RouteManager.unregister(this._routeToken);
        this._routeToken = null;
      }
      if (newRoute) {
        var options = {
          willDeactivate: this._boundWillDeactivate,
          deactivate: this._boundDeactivate,
          willActivate: this._boundWillActivate,
          activate: this._boundActivate
        }
        if (this.routeAlias) {
          options.alias = this.routeAlias;
        }
        this._routeToken = Excess.RouteManager.register(newRoute, options);
      }
      // this._broadcastPathChangeToChildren();
    }

  });

})();
</script>
